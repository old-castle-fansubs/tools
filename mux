#!/usr/bin/python3
import os
import re
import subprocess
import argparse
import zlib
from pathlib import Path
from collections import namedtuple
import pysubs2


Chapter = namedtuple('Chapter', ('start_time', 'end_time', 'title', 'hidden'))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('ep')
    parser.add_argument('-v', '--version', type=int, default=1)
    return parser.parse_args()


def mux(video_path, subs_path, chapters_path, font_paths, output_path):
    mux_args = ['mkvmerge', '-o', output_path, video_path]

    if subs_path:
        mux_args.extend([subs_path])

    if chapters_path:
        mux_args.extend(['--chapters', chapters_path])

    for font_path in font_paths:
        mux_args.extend([
            '--attachment-mime-type', 'application/x-truetype-font',
            '--attach-file', font_path
        ])

    status = subprocess.run(mux_args)
    if status.returncode != 0:
        raise RuntimeError('Error while muxing')


def get_title(subs_path):
    return dict(pysubs2.SSAFile.load(subs_path).info)['Title']


def get_video_length(path):
    status = subprocess.run([
        'ffprobe',
        '-i', str(path),
        '-show_entries', 'format=duration',
        '-v', 'quiet',
        '-of', 'csv=p=0',
        '-sexagesimal',
    ], stdout=subprocess.PIPE)
    if status.returncode != 0:
        raise RuntimeError('Error while getting video length')
    result = re.match(r'(\d+):(\d+):(\d+)\.(\d+)', status.stdout.decode())
    groups = list(result.groups())
    groups[-1] = groups[-1][:3]
    return '{:02d}:{:02d}:{:02d}.{:03d}'.format(*[int(g) for g in groups])


def get_chapters_legacy(chapters_spec_path, video_length):
    lines = [
        line.split(' ', maxsplit=1)
        for line in chapters_spec_path.read_text().split('\n')
        if line]

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def get_chapters_new(subs_path, video_length):
    lines = []
    for line in pysubs2.SSAFile.load(subs_path):
        if line.name == 'Chapter':
            lines.append((
                pysubs2.time.ms_to_str(line.start, fractions=True),
                line.text))

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def create_chapters_file(chapters):
    chapters = list(chapters)
    if not chapters:
        return None
    chapters_path = Path('tmp.xml')
    with chapters_path.open('w') as handle:
        handle.write('<?xml version="1.0" encoding="ISO-8859-1"?>\n')
        handle.write('<!DOCTYPE Chapters SYSTEM "matroskachapters.dtd">\n')
        handle.write('<Chapters>\n')
        handle.write('\t<EditionEntry>\n')
        handle.write('\t\t<EditionFlagDefault>1</EditionFlagDefault>\n')
        handle.write('\t\t<EditionFlagOrdered>1</EditionFlagOrdered>\n')
        handle.write('\t\t<EditionFlagHidden>0</EditionFlagHidden>\n')
        for chapter in chapters:
            handle.write(
                '\t\t<ChapterAtom>\n'
                '\t\t\t<ChapterTimeStart>{start_time}</ChapterTimeStart>\n'
                '\t\t\t<ChapterTimeEnd>{end_time}</ChapterTimeEnd>\n'
                '\t\t\t<ChapterFlagEnabled>{enabled:d}</ChapterFlagEnabled>\n'
                '\t\t\t<ChapterFlagHidden>{hidden:d}</ChapterFlagHidden>\n'
                '\t\t\t<ChapterDisplay>\n'
                '\t\t\t\t<ChapterString>{title}</ChapterString>\n'
                '\t\t\t\t<ChapterLanguage>eng</ChapterLanguage>\n'
                '\t\t\t</ChapterDisplay>\n'
                '\t\t</ChapterAtom>\n'
                .format(
                    enabled=True,
                    start_time=chapter.start_time,
                    end_time=chapter.end_time,
                    title=chapter.title,
                    hidden=chapter.hidden))
        handle.write('\t</EditionEntry>\n')
        handle.write('</Chapters>')
    return chapters_path


def change_crc(path, checksum):
    tmp_path = Path('tmp.dat')
    status = subprocess.run([
        'crcmanip', 'patch', path, tmp_path, '%08x' % checksum])
    if status.returncode != 0:
        raise RuntimeError('Error while patching CRC')
    path.unlink()
    tmp_path.rename(path)


def main():
    args = parse_args()
    episode = args.ep
    version = args.version

    source_subs_path = Path('%s.ass' % episode)
    source_video_path = next(
        (p for p in Path('source').iterdir() if p.stem == episode), None)
    source_chapters_path = Path('chapters/%s.txt' % episode)
    source_font_path = [p for p in Path('fonts').iterdir()]

    if not source_subs_path.exists():
        raise RuntimeError('No subs file found')
    if not source_video_path:
        raise RuntimeError('No video file found')
    if not source_font_path:
        raise RuntimeError('No fonts found')

    title = get_title(source_subs_path)
    checksum = zlib.crc32(title.encode()) & 0xFFFF0000
    checksum |= version << 12
    try:
        checksum |= int(episode)
    except ValueError:
        pass
    target_video_path = Path(f'[OldCastle] {title} [{checksum:08X}].mkv')

    video_length = get_video_length(source_video_path)
    if source_chapters_path.exists():
        chapters = get_chapters_legacy(source_chapters_path, video_length)
    else:
        chapters = get_chapters_new(source_subs_path, video_length)
    target_chapters_path = create_chapters_file(chapters)
    mux(
        source_video_path,
        source_subs_path,
        target_chapters_path,
        source_font_path,
        target_video_path)
    if target_video_path.exists():
        target_chapters_path.unlink()

    change_crc(target_video_path, checksum)


if __name__ == '__main__':
    main()

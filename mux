#!/usr/bin/python3
import re
import subprocess
import argparse
import zlib
from pathlib import Path
from collections import namedtuple
import pysubs2
import ass_tag_parser
import fontTools.ttLib as font_tools


StyleInfo = namedtuple('StyleInfo', ('family', 'bold', 'italic'))
Chapter = namedtuple('Chapter', ('start_time', 'end_time', 'title', 'hidden'))

TT_NAME_ID_FONT_FAMILY = 1
TT_NAME_ID_FULL_NAME = 4
TT_NAME_ID_TYPOGRAPHIC_FAMILY = 16
TT_PLATFORM_MICROSOFT = 3


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('ep')
    parser.add_argument('-v', '--version', type=int, default=1)
    return parser.parse_args()


def mux(video_path, subs_path, chapters_path, font_paths, output_path):
    mux_args = ['mkvmerge', '-o', output_path, video_path]

    if subs_path:
        mux_args.extend([subs_path])

    if chapters_path:
        mux_args.extend(['--chapters', chapters_path])

    for font_path in font_paths:
        mux_args.extend([
            '--attachment-mime-type', 'application/x-truetype-font',
            '--attach-file', font_path
        ])

    status = subprocess.run(mux_args)
    if status.returncode != 0:
        raise RuntimeError('Error while muxing')


def get_title(subs_path):
    return dict(pysubs2.SSAFile.load(subs_path).info)['Title']


def get_video_length(path):
    status = subprocess.run([
        'ffprobe',
        '-i', str(path),
        '-show_entries', 'format=duration',
        '-v', 'quiet',
        '-of', 'csv=p=0',
        '-sexagesimal',
    ], stdout=subprocess.PIPE)
    if status.returncode != 0:
        raise RuntimeError('Error while getting video length')
    result = re.match(r'(\d+):(\d+):(\d+)\.(\d+)', status.stdout.decode())
    groups = list(result.groups())
    groups[-1] = groups[-1][:3]
    return '{:02d}:{:02d}:{:02d}.{:03d}'.format(*[int(g) for g in groups])


def get_chapters_legacy(chapters_spec_path, video_length):
    lines = [
        line.split(' ', maxsplit=1)
        for line in chapters_spec_path.read_text().split('\n')
        if line]

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def get_chapters_new(subs_path, video_length):
    lines = []
    for line in pysubs2.SSAFile.load(subs_path):
        if line.name == 'Chapter':
            lines.append((
                pysubs2.time.ms_to_str(line.start, fractions=True),
                line.text))

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def create_chapters_file(chapters):
    chapters = list(chapters)
    if not chapters:
        return None
    chapters_path = Path('tmp.xml')
    with chapters_path.open('w') as handle:
        handle.write('<?xml version="1.0" encoding="ISO-8859-1"?>\n')
        handle.write('<!DOCTYPE Chapters SYSTEM "matroskachapters.dtd">\n')
        handle.write('<Chapters>\n')
        handle.write('\t<EditionEntry>\n')
        handle.write('\t\t<EditionFlagDefault>1</EditionFlagDefault>\n')
        handle.write('\t\t<EditionFlagOrdered>1</EditionFlagOrdered>\n')
        handle.write('\t\t<EditionFlagHidden>0</EditionFlagHidden>\n')
        for chapter in chapters:
            handle.write(
                '\t\t<ChapterAtom>\n'
                '\t\t\t<ChapterTimeStart>{start_time}</ChapterTimeStart>\n'
                '\t\t\t<ChapterTimeEnd>{end_time}</ChapterTimeEnd>\n'
                '\t\t\t<ChapterFlagEnabled>{enabled:d}</ChapterFlagEnabled>\n'
                '\t\t\t<ChapterFlagHidden>{hidden:d}</ChapterFlagHidden>\n'
                '\t\t\t<ChapterDisplay>\n'
                '\t\t\t\t<ChapterString>{title}</ChapterString>\n'
                '\t\t\t\t<ChapterLanguage>eng</ChapterLanguage>\n'
                '\t\t\t</ChapterDisplay>\n'
                '\t\t</ChapterAtom>\n'
                .format(
                    enabled=True,
                    start_time=chapter.start_time,
                    end_time=chapter.end_time,
                    title=chapter.title,
                    hidden=chapter.hidden))
        handle.write('\t</EditionEntry>\n')
        handle.write('</Chapters>')
    return chapters_path


def change_crc(path, checksum):
    tmp_path = Path('tmp.dat')
    status = subprocess.run([
        'crcmanip', 'patch', path, tmp_path, '%08x' % checksum])
    if status.returncode != 0:
        raise RuntimeError('Error while patching CRC')
    path.unlink()
    tmp_path.rename(path)


def get_used_font_styles(subs_path):
    subs = pysubs2.SSAFile.load(subs_path)

    style_name_to_style_info = {
        style_name: StyleInfo(style.fontname, style.bold, style.italic)
        for style_name, style in subs.styles.items()
    }

    used_font_styles = set()
    for i, line in enumerate(subs):
        if line.is_comment:
            continue
        try:
            used_font_styles.add(style_name_to_style_info[line.style])
        except KeyError as ex:
            print(f'Invalid style at line #{i + 1}: {line.style}')

        bold = style_name_to_style_info[line.style].bold
        italic = style_name_to_style_info[line.style].italic

        result = ass_tag_parser.parse_ass(line.text)
        for chunk in result:
            if chunk['type'] != 'tags':
                continue
            for ass_tag in chunk['children']:
                if ass_tag['type'] == 'bold':
                    if 'enabled' in ass_tag:
                        bold = ass_tag['enabled']
                    else:
                        bold = ass_tag['weight'] > 100
                elif ass_tag['type'] == 'italics':
                    italic = ass_tag['enabled']

                elif ass_tag['type'] == 'font-name':
                    used_font_styles.add(
                        StyleInfo(ass_tag['name'], bold, italic))
    return used_font_styles


def filter_fonts(used_font_styles, font_paths):
    def is_bold(font):
        return True if font['OS/2'].fsSelection & (1 << 5) else False

    def is_italic(font):
        return True if font['OS/2'].fsSelection & 1 else False

    def get_font_names(font):
        for record in font['name'].names:
            if record.nameID in {
                    TT_NAME_ID_FONT_FAMILY,
                    TT_NAME_ID_FULL_NAME,
                    TT_NAME_ID_TYPOGRAPHIC_FAMILY} \
                and record.platformID == TT_PLATFORM_MICROSOFT:
                yield record.string.decode('utf-16-be')

    print('Used font styles:')

    ret = set()
    for style in sorted(used_font_styles, key=lambda s: s.family):
        candidates = []
        for font_path in font_paths:
            font = font_tools.TTFont(font_path)
            font_path_names = get_font_names(font)
            if style.family.lower() in [n.lower() for n in font_path_names]:
                candidates.append((
                    (is_bold(font) == style.bold) +
                    (is_italic(font) == style.italic),
                    font_path))
        candidates.sort(key=lambda i: -i[0])

        print(
            '{}{} {:40s} '.format(
                'B' if style.bold else ' ',
                'I' if style.italic else ' ',
                style.family),
            end='')

        if candidates:
            selected_font_path = candidates[0][1]
            ret.add(selected_font_path)
            print('"{}"'.format(selected_font_path.resolve()))
        else:
            print('-')

    return ret


def main():
    args = parse_args()
    episode = args.ep
    version = args.version

    source_subs_path = Path('%s.ass' % episode)
    source_video_path = next(
        (p for p in Path('source').iterdir() if p.stem == episode), None)
    source_chapters_path = Path('chapters/%s.txt' % episode)
    source_font_paths = [p for p in Path('fonts').iterdir()]

    if not source_subs_path.exists():
        raise RuntimeError('No subs file found')
    if not source_video_path:
        raise RuntimeError('No video file found')
    if not source_font_paths:
        raise RuntimeError('No fonts found')

    used_font_styles = get_used_font_styles(source_subs_path)
    target_font_paths = filter_fonts(used_font_styles, source_font_paths)

    title = get_title(source_subs_path)
    checksum = zlib.crc32(title.encode()) & 0xFFFF0000
    checksum |= version << 12
    try:
        checksum |= int(episode)
    except ValueError:
        pass
    target_video_path = Path(f'[OldCastle] {title} [{checksum:08X}].mkv')

    video_length = get_video_length(source_video_path)
    if source_chapters_path.exists():
        chapters = get_chapters_legacy(source_chapters_path, video_length)
    else:
        chapters = get_chapters_new(source_subs_path, video_length)
    target_chapters_path = create_chapters_file(chapters)
    mux(
        source_video_path,
        source_subs_path,
        target_chapters_path,
        target_font_paths,
        target_video_path)
    if target_chapters_path and target_chapters_path.exists():
        target_chapters_path.unlink()

    change_crc(target_video_path, checksum)


if __name__ == '__main__':
    main()

#!/usr/bin/python3
import os
import re
import subprocess
import argparse
import zlib
from pathlib import Path
import pysubs2


class Chapter:
    def __init__(self, start_time, end_time, title, hidden):
        self.start_time = start_time
        self.end_time = end_time
        self.title = title
        self.hidden = hidden


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('ep')
    parser.add_argument('-v', '--version', type=int, default=1)
    return parser.parse_args()


def mux(video_path, subs_path, chapters_path, font_paths, output_path):
    mux_args = ['mkvmerge', '-o', output_path, video_path]

    if subs_path:
        mux_args.extend([subs_path])

    if chapters_path:
        mux_args.extend(['--chapters', chapters_path])

    for font_path in font_paths:
        mux_args.extend([
            '--attachment-mime-type', 'application/x-truetype-font',
            '--attach-file', font_path
        ])

    status = subprocess.run(mux_args)
    if status.returncode != 0:
        raise RuntimeError('Error while muxing')


def get_video_length(path):
    status = subprocess.run([
        'ffprobe',
        '-i', str(path),
        '-show_entries', 'format=duration',
        '-v', 'quiet',
        '-of', 'csv=p=0',
        '-sexagesimal',
    ], stdout=subprocess.PIPE)
    if status.returncode != 0:
        raise RuntimeError('Error while getting video length')
    result = re.match(r'(\d+):(\d+):(\d+)\.(\d+)', status.stdout.decode())
    groups = list(result.groups())
    groups[-1] = groups[-1][:3]
    return '{:02d}:{:02d}:{:02d}.{:03d}'.format(*[int(g) for g in groups])


def get_chapters_legacy(chapters_spec_file, video_length):
    lines = [
        line.split(' ', maxsplit=1)
        for line in chapters_spec_file.read_text().split('\n')
        if line]

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def get_chapters_new(subs_file, video_length):
    lines = []
    for line in pysubs2.SSAFile.load(subs_file):
        if line.name == 'Chapter':
            lines.append((
                pysubs2.time.ms_to_str(line.start, fractions=True),
                line.text))

    for i, (start_time, title) in enumerate(lines):
        try:
            end_time = lines[i + 1][0]
        except IndexError:
            end_time = video_length

        if title.startswith('#'):
            continue
        if title.startswith('$'):
            yield Chapter(start_time, end_time, title[1:], True)
        else:
            yield Chapter(start_time, end_time, title, False)


def create_chapters_file(chapters):
    chapters_file = Path('tmp.xml')
    with chapters_file.open('w') as handle:
        handle.write('<?xml version="1.0" encoding="ISO-8859-1"?>\n')
        handle.write('<!DOCTYPE Chapters SYSTEM "matroskachapters.dtd">\n')
        handle.write('<Chapters>\n')
        handle.write('\t<EditionEntry>\n')
        handle.write('\t\t<EditionFlagDefault>1</EditionFlagDefault>\n')
        handle.write('\t\t<EditionFlagOrdered>1</EditionFlagOrdered>\n')
        handle.write('\t\t<EditionFlagHidden>0</EditionFlagHidden>\n')
        for chapter in chapters:
            handle.write(
                '\t\t<ChapterAtom>\n'
                '\t\t\t<ChapterTimeStart>{start_time}</ChapterTimeStart>\n'
                '\t\t\t<ChapterTimeEnd>{end_time}</ChapterTimeEnd>\n'
                '\t\t\t<ChapterFlagEnabled>{enabled:d}</ChapterFlagEnabled>\n'
                '\t\t\t<ChapterFlagHidden>{hidden:d}</ChapterFlagHidden>\n'
                '\t\t\t<ChapterDisplay>\n'
                '\t\t\t\t<ChapterString>{title}</ChapterString>\n'
                '\t\t\t\t<ChapterLanguage>eng</ChapterLanguage>\n'
                '\t\t\t</ChapterDisplay>\n'
                '\t\t</ChapterAtom>\n'
                .format(enabled=True, **chapter.__dict__))
        handle.write('\t</EditionEntry>\n')
        handle.write('</Chapters>')
    return chapters_file


def change_crc(path, checksum):
    tmp_file = Path('tmp.dat')
    status = subprocess.run([
        'crcmanip', 'patch', path, tmp_file, '%08x' % checksum])
    if status.returncode != 0:
        raise RuntimeError('Error while patching CRC')
    path.unlink()
    tmp_file.rename(path)


def main():
    args = parse_args()
    episode = args.ep
    version = args.version

    series = os.path.basename(os.getcwd())
    source_subs_file = Path('%s.ass' % episode)
    source_video_file = next(
        (p for p in Path('source').iterdir() if p.stem == episode), None)
    source_chapters_file = Path('chapters/%s.txt' % episode)
    source_font_files = [p for p in Path('fonts').iterdir()]

    if not source_subs_file.exists():
        raise RuntimeError('No subs file found')
    if not source_video_file:
        raise RuntimeError('No video file found')
    if not source_font_files:
        raise RuntimeError('No fonts found')

    checksum = (
        (zlib.crc32(f'{series} {episode}'.encode()) & 0xFFFF0000)
        | (version << 12)
        | int(episode))

    target_video_file = Path(
        f'[OldCastle] {series} - {episode} [{checksum:08X}].mkv')

    video_length = get_video_length(source_video_file)
    if source_chapters_file.exists():
        chapters = get_chapters_legacy(source_chapters_file, video_length)
    else:
        chapters = get_chapters_new(source_subs_file, video_length)
    target_chapters_file = create_chapters_file(chapters)
    mux(
        source_video_file,
        source_subs_file,
        target_chapters_file,
        source_font_files,
        target_video_file)
    target_chapters_file.unlink()

    change_crc(target_video_file, checksum)


if __name__ == '__main__':
    main()

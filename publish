#!/usr/bin/env python3
import pathlib
import subprocess
import json
import tempfile
import shlex

import configargparse
import requests
import torf
import tqdm
import xdg


TRACKERS = [
    'http://anidex.moe:6969/announce',
    'udp://tracker.pirateparty.gr:6969/announce'
    'udp://tracker.coppersurfer.tk:6969/announce',
    'udp://tracker.internetwarriors.net:1337/announce',
    'udp://tracker.leechers-paradise.org:6969/announce',
    'udp://tracker.zer0day.to:1337/announce',
    'udp://tracker.opentrackr.org:1337/announce',
    'udp://tracker.cyberia.is:6969/announce',
    'udp://open.stealth.si:80/announce',
    'udp://tracker.uw0.xyz:6969',
    'http://nyaa.tracker.wf:7777/announce',
]

ANIDEX_API_URL = 'https://anidex.info/api/'
ANIDEX_CATEGORY_IDS = {
    '1':  'Anime - Sub',
    '2':  'Anime - Raw',
    '3':  'Anime - Dub',
    '4':  'LA - Sub',
    '5':  'LA - Raw',
    '6':  'Light Novel',
    '7':  'Manga - TLed',
    '8':  'Manga - Raw',
    '9':  'Music - Lossy',
    '10': 'Music - Lossless',
    '11': 'Music - Video',
    '12': 'Games',
    '13': 'Applications',
    '14': 'Pictures',
    '15': 'Adult Video',
    '16': 'Other',
}

NYAA_SI_API_URL = 'https://nyaa.si/api/upload'
NYAA_SI_CATEGORY_IDS = {
    '1_1': 'Anime - AMV',
    '1_2': 'Anime - English',
    '1_3': 'Anime - Non-English',
    '1_4': 'Anime - Raw',
    '2_1': 'Audio - Lossless',
    '2_2': 'Audio - Lossy',
    '3_1': 'Literature - English-translated',
    '3_2': 'Literature - Non-English',
    '3_3': 'Literature - Non-English-Translated',
    '3_4': 'Literature - Raw',
    '4_1': 'Live Action - English-translated',
    '4_2': 'Live Action - Idol/Promotional Video',
    '4_3': 'Live Action - Non-English-translated',
    '4_4': 'Live Action - Raw',
    '5_1': 'Pictures - Graphics',
    '5_2': 'Pictures - Photos',
    '6_1': 'Software - Applications',
    '6_2': 'Software - Games',
}


def parse_args():
    parser = configargparse.ArgumentParser(
        formatter_class=configargparse.RawTextHelpFormatter,
        default_config_files=[
            pathlib.Path(xdg.XDG_CONFIG_HOME) / 'oc-tools.yml'
        ]
    )

    parser.add_argument('--dry-run', action='store_true')

    parser.add_argument('--anidex-key', required=True)
    parser.add_argument(
        '--anidex-cat',
        required=True,
        choices=ANIDEX_CATEGORY_IDS.keys(),
        metavar='ANIDEX_CATEGORY',
        help='\n'.join(
            f'{key}: {value}' for key, value in ANIDEX_CATEGORY_IDS.items()
        )
    )
    parser.add_argument('--anidex-lang', required=True, type=int)
    parser.add_argument('--anidex-group', required=True, type=int)

    parser.add_argument('--nyaasi-user', required=True)
    parser.add_argument('--nyaasi-pass', required=True)
    parser.add_argument('--nyaasi-info', required=True)
    parser.add_argument(
        '--nyaasi-cat',
        required=True,
        choices=NYAA_SI_CATEGORY_IDS.keys(),
        metavar='NYAASI_CATEGORY',
        help='\n'.join(
            f'{key}: {value}' for key, value in NYAA_SI_CATEGORY_IDS.items()
        )
    )

    parser.add_argument('--target-host', required=True, type=pathlib.Path)
    parser.add_argument('--target-data-dir', required=True, type=pathlib.Path)
    parser.add_argument(
        '--target-torrent-dir', required=True, type=pathlib.Path
    )

    parser.add_argument('path', type=pathlib.Path)
    return parser.parse_known_args()[0]


def sync(local_data_path, target_host, target_data_path):
    print(
        f'Uploading "{local_data_path}" '
        f'to "{target_data_path}" on {target_host}'
    )

    result = subprocess.run([
        'rsync',
        '-ahs',
        '--progress',
        local_data_path,
        f'{target_host}:{target_data_path}'
    ])

    if result.returncode != 0:
        exit(1)


def sync_data_files(local_data_path, target_host, target_data_dir):
    sync(local_data_path, target_host, target_data_dir)


def get_target_torrent_path(local_data_path, target_torrent_dir):
    if local_data_path.is_file():
        return target_torrent_dir / (local_data_path.stem + '.torrent')
    return target_torrent_dir / (local_data_path.name + '.torrent')


def build_torrent_file(local_data_path):
    print('Building torrent file')
    handle, temp_torrent_path = tempfile.mkstemp(suffix='.torrent')
    temp_torrent_path = pathlib.Path(temp_torrent_path)
    torrent = torf.Torrent(path=local_data_path, trackers=TRACKERS)

    with tqdm.tqdm(total=9e9) as bar:
        def callback(_torrent, filepath, pieces_done, pieces_total):
            bar.set_description(filepath)
            bar.update(pieces_done - bar.n)
            bar.total = pieces_total

        torrent.generate(callback)

    torrent.write(temp_torrent_path, overwrite=True)
    return temp_torrent_path


def sync_torrent_file(local_torrent_path, target_host, target_torrent_path):
    sync(local_torrent_path, target_host, target_torrent_path)


def submit_to_transmission(target_host, target_torrent_path):
    result = subprocess.run([
        'ssh',
        target_host,
        'transmission-remote',
        '-a',
        shlex.quote(str(target_torrent_path))
    ])

    if result.returncode != 0:
        exit(1)


def publish_torrent_nyaa(
        user,
        password,
        name,
        information,
        description,
        category_id,
        local_torrent_path,
        dry_run
):
    with local_torrent_path.open('rb') as handle:
        data = {
            'torrent_data': json.dumps({
                'name': name,
                'category': category_id,
                'information': information,
                'description': description,
                'anonymous': False,
                'hidden': False,
                'complete': False,
                'remake': False,
                'trusted': True,
            })
        }
        files = {
            'torrent': handle,
        }

        if dry_run:
            print(data)
            print(files)
        else:
            result = requests.post(
                NYAA_SI_API_URL,
                auth=(user, password),
                data=data,
                files=files
            )
            try:
                response = result.json()
            except ValueError:
                print('Bad response:')
                print(result.status_code)
                print(result.text)
                exit(1)

            errors = response.get('errors')
            if errors:
                print('Upload failed', errors)
                exit(1)
            else:
                print(response['url'])


def publish_torrent_anidex(
        api_key,
        category_id,
        language_id,
        group_id,
        local_torrent_path,
        dry_run
):
    with local_torrent_path.open('rb') as handle:
        data = {
            'api_key': api_key,
            'subcat_id': category_id,
            'lang_id': language_id,
            'group_id': group_id,
            'tt_api': 1,
            'private': 0,
        }
        files = {'file': handle}

        if dry_run:
            print(data)
            print(files)
        else:
            result = requests.post(ANIDEX_API_URL, data=data, files=files)
            print(result.text)


def main():
    args = parse_args()

    temp_torrent_path = build_torrent_file(args.path)
    target_torrent_path = get_target_torrent_path(
        args.path, args.target_torrent_dir
    )

    sync_data_files(args.path, args.target_host, args.target_data_dir)
    sync_torrent_file(temp_torrent_path, args.target_host, target_torrent_path)

    submit_to_transmission(args.target_host, target_torrent_path)

    publish_torrent_nyaa(
        args.nyaasi_user,
        args.nyaasi_pass,
        args.path.name,
        args.nyaasi_info,
        '',
        args.nyaasi_cat,
        temp_torrent_path,
        args.dry_run
    )

    publish_torrent_anidex(
        args.anidex_key,
        args.anidex_cat,
        args.anidex_lang,
        args.anidex_group,
        temp_torrent_path,
        args.dry_run
    )

    temp_torrent_path.unlink()


if __name__ == '__main__':
    main()
